#include <stdio.h>
/*int main()
{
    int i=0;
    int arr[10]={1,2,3,4,5,6,7,8,9,10};
    for(i=0;i<=12;i++)
    {
        arr[i]=0;
        printf("hehe\n");
    }
    char j='a';
    int* p=&j;
    printf("%d\n",j);
    printf("%p\n",p);
    printf("%p\n",&j);
    return 0;
}*/
// release与debug版本对内存分配顺序不一样（优化）
// 数据在内存中的存储
// 整型家族：char int short long long long
// char a是否等于signed char a取决于编译器
// int a = signed int a其高位存放1和0用于区别数据的正负，使得真正利用到的空间只有31位bit位
// 而现实生活中存在一些非负的数据，eg：年龄，身高，体重；这些数据就可以用无符号位来表示，其使得32位bit位都有意义
// 浮点型家族（表示小数）：float与double
// 构造类型：自定义类型（自己创建出新的类型）
// 数组类型，结构体类型，枚举类型，联合类型，指针类型，空类型（void）

// 空间大小由不同的类型决定的
// cpu只有加法器，数值统一用补码进行存储，方便计算

// 大小端：（一个数据在内存进行存储的顺序）字节序是指以字节为单位的存储顺序；
// 0x11223344:低地址-----11223344（大端字节序存储）-------（另一种）44332211（小端字节序存储）------------------------>高地址
// 大端字节序存储：把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处，就是大端字节序存储。
/*int main()大小端判断
{
    int a=1;
    int*p=(char*)&a;
    if(*p==1)
    {
        printf("xiaoduan\n");
    }
    else
    {
        printf("daduan\n");
    }
    return 0;
}*/
/*int main()
{
    char a = -1;
    signed char b = -1;
    unsigned char c = -1;
    printf("a=%d, b=%d, c=%d", a, b, c);
    //当数据存放到char a中时会进行数据截断，%d时会进行整型提升，
    //补0还是补1由符号位决定
    char b = 128;
    printf("%d\n",b);
    //%u-打印无符号整数
    return 0;
}*/
// size_t相当于unsigned int
/*int my_strlen(const char*str)
{
    int count=0;
    while(*str)
    {
        count++;
        str++;
    }
    return count;
}
int main()
{
    if(my_strlen("abc")-my_strlen("abcdef")>=0)
    printf(">\n");
    else
    printf("<\n");

    return 0;
}*/
//
// 浮点数在内存的存储规则（科学计数法一样的）：任意一个二进制浮点数V可以表示为下面的形式
// （-1）^S*M*2^E:（-1^S）表示符号位;V为正数,S位0；当S=1时，V为负数
// M表示有效数字，大于等于1，小于2；
// 2^E表示指数位
// V=5.0f---》101.0---》1.10*2^2
// V=9.5f---》1001.1---》1.0011*2^3:S=0；M=1.0011；E=3；
// float：IEEE754规定：
// 对于32位的浮点数，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M
// double：
// 对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。
// float：当E为负数是给E（真实值）加上127（中间值）（相加过程采用二进制加法）
// double：。。。。。。。。。。。加1023

// 5.5
// 101.1
// 1.011*2^2
//  s=0 m=1.011 e=2
// 0 10000001 011 00000000000000000000
// 0100 0000 1011 0000 0000 0000 0000 0000
// 4    0    b    0    0    0    0    0
// 0X40b00000（小端字节存放）

// E为全0时：E=1-127/E=1-1023
// 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，
// 有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示0，以及接近于0的很小的数字

// E全为1
// 这时，如果有效数字M全为0，表示+—无穷大（正负取决于符号位s）

int main()
{
    int n = 9;
    //0000000000000000000000000000000000001001
    //0 00000000 0000000000000000000000000001001
    //E=-126
    //M=0.00000000000000000000001001
    //+0.00000000000000000000001001*2^-126
    //
    float *pFloat = (float *)&n;
    printf("n的值为:%d\n", n);//9
    printf("*pFloat#H>: %f\n", *pFloat);//0.000000000000000...
    *pFloat = 9.0;
    //1001.0
    //1.001*2^3
    //S=0
    //E=3
    //M=1.001
    //0 10000010 001000000000000000000000
    //010000100010000000000000000000000
    printf("num的值为:%d\n", n);//1091567616面对%d打印的时候用的是补码
    printf("*pFloat的值为:%f\n",*pFloat);//9.000000
    return 0;
}